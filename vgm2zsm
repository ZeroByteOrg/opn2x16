#!/usr/bin/php -f
<?php

if (isset($argv[1]))
	define("FILENAME", $argv[1]);
else
	define("FILENAME", 'kenstage.vgm');
define("OFFSET", 0x34);
define("MAXPAUSE",0x7f);
define("PERLINE",16); // # of data bytes to print per line
define("TICKSPERFRAME",735);
define("OUTFILENAME", 'BGM.ZSM');

$commands=array(
  0x63 => 0,	// delay 0x0000
  0x66 => 0xff, // end of song
  0x54 => 0x01, // YM2151 message
);

// For R39, use the 3.5MHz table (name it as $note)

// C#,D,D#,x,E,F,F#,x,G,G#,A,x,A#,B,C
$note = array( // values for when YM2151 is at 3.5MHz
	277.18, 293.66, 311.13, 0,  // c# d  d#  x
	329.63, 349.23, 369.99, 0,  // e  f  f#  x
	392.00, 415.30, 440.00, 0,  // g  g# a   x
	466.16, 493.88, 523.25, 0); // a# b  c   x   

$note1 = array( // values for when YM2151 is at 4MHz
	311.13, 329.63, 349.23, 0,  // c# d  d#  x
	369.99, 392.00, 415.30, 0,  // e  f  f#  x
	440.00, 466.16, 493.88, 0,  // g  g# a   x
	523.25, 554.37, 587.33, 0); // a# b  c   x   

// LUT for converting AY volume register into VERA PSG equivalent %max
$PSGvolume = array( 0,1,2,3,4,8,12,16,24,28,34,40,45,51,58,63);
		
		
// from fmtoy, 2203 uses this to make the notes:
//    uint8_t octave = (69 + 12 * log2(pitch / 440.0)) / 12 - 1;
//    uint16_t fnum = (144 * pitch * (1 << 19) / channel->chip->clock) / (1 << (octave - 1));

function freq($oct,$code) {
	global $note;

	return (round($note[$code] * pow(2,$oct-4),2));
}

function psgfnum($ayfnum) {
	global $ayclock;
	if($ayfnum < 1) { return 0; }
	$freq = $ayclock / (16 * $ayfnum); // per AY-3-8910 datasheet
printf("   ----- Frequency calculated as %f\n",$freq);
	// the magic number 0.3725... is computed from the VERA docs
	return round($freq / 0.37252903, 0, PHP_ROUND_HALF_UP);
}

function getcode ($freq) {
	global $note;
	$ymoct = 0;
	$ymc = 0;
	$ymmin = 9999999;
	$bestOct = 0;
	$bestC   = 0;
	while ($ymoct < 8) {
		for ($ymc=0;$ymc<15;$ymc++) {
			if ($note[$ymc]!=0) {
				$dif = abs(freq($ymoct,$ymc)-$freq);
				if ($dif < $ymmin) {
					$ymmin = $dif;
					$bestOct = $ymoct;
					$bestC   = $ymc;
				};
				if ($dif > $ymmin) { break 2; };
			};
		};
		$ymoct++;
	};
//	printf("0x%04x", ($bestC & 0x0f) | ($bestOct << 4)); // omit DT for now.
	return (($bestC & 0x0f) | ($bestOct << 4));
};

function tobin($val) {
	$s = "";
	for ($i=7 ; $i >= 0 ; $i--) {
		if ($val >> $i & 0x01 == 1) { $s = $s . "1"; }
		else { $s = $s . "0"; }
		if ($i == 4) { $s = $s . " "; }
	}
	return $s;
}


// --------- above is the set of LUTs / magic numbers I used for OPL->OPM freq. conversion.


$opnfreqs = array( 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 ); // 0x80 is an invalid value used as a flag indicating "not set"

//$segafreqs = array ( 617, 653, 692, 733, 777, 823, 872, 924, 979, 1037, 1099, 1164 );
////$segafreqs = array ( 644, 682, 723, 766, 811, 859, 910, 965, 1022, 1083, 1147, 1215 ); // Deflemask uses these values for KC

//$kc = array ( 0xe, 0, 1, 2, 4, 5, 6, 8, 9, 0xa, 0xc, 0xd ); // do the above notes even map the same way? Nobody even says....
  

function writepause() {
  global $songdata;
  global $ticks;
  
  $frames = intdiv($ticks,TICKSPERFRAME);
  $ticks  = $ticks % TICKSPERFRAME;
  while ($frames >= MAXPAUSE) {
	  array_push($songdata,0,MAXPAUSE);
	  $frames -= MAXPAUSE;
  }
  if ($frames > 0) {
	array_push($songdata,0,$frames);
  }
}

function generate($c, $a, $d) {
	global $songdata;
	global $ticks;
	global $commands;
	global $totalticks;
	global $longest;
	global $maxatbyte;
	global $i;

	writepause();
	$totalticks += $ticks;
	if ($ticks > $longest) {
		// track what the longest pause was over the entire stream
		$longest = $ticks;
		$maxatbyte = $i-3;
	};
	array_push($songdata,$c,$a,$d);
if ($c == 2) { printf("ZSM WRITE: 0x02 0x%02x 0x%02x\n",$a,$d); }
};

function out_asm()
{
	global $songdata;
	global $bytes;
	
	print "songdata";
	for ($j=0;$j<sizeof($songdata);$j++) {
	  $bytes++;
	  if ($j%PERLINE != 0) {
		print ",";
	  } else {
		print "\n\tbyte ";
	  };
	  printf('$%02x',$songdata[$j]);
	};
	print "\n";
}

function out_zsm($ofile)
{
	global $songdata;
	$of = fopen($ofile, "w+b");
	fwrite($of,"zm");
	fwrite($of,pack('C*',...$songdata));
	fclose($of);
}

function translate_ay($a, $d)
{
	global $ayshadow;
	global $psgshadow;
	global $PSGvolume;
	
	// Registers:
	// 0, 2, 4 = fnum (A,B,C - 12-bit)
	// 6 = noise period (5-bit)
	// 7 = bits 0-2 = Tone Enable A,B,C (0=enable!!!)
	//     bits 3-5 = Noise Enabl A,B,C (0=enable!!!)
	//     bits 6-7 = IO port direction (ignore)
	// 8-A = volume 4lsb, bit 4 = M (reading this soon)
	// B-C = envelope period (16bit little endian)
	// D = ENV shape/cycle:
	//     0: hold
	//     1: Alt.
	//     2: Att
	//     3: CONT.
	// E-F = IO port data (ignore)

printf("VGM: SSG command: 0x%02x 0x%02x\n",$a,$d);
	switch ($a) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		$cha = intdiv($a,2);
printf ("------- SSG Set Tone Frequency voice %d  (0x%02x)\n", $cha, $a);
printf ("   - AY shadow:  0x%04x\n",$ayshadow[$cha]);
		if ($a & 1 == 1) {
printf ("   - writing  :  0x%02x..\n",$d);
			$ayshadow[$cha] &= 0xff;
			$ayshadow[$cha] += $d << 8;
			
		}
		else {
printf ("   - writing  :  0x..%02x\n",$d);
			$ayshadow[$cha] &= 0x0f00;
			$ayshadow[$cha] += $d;
		}
printf ("   - new AYfrq:  0x%04x\n",$ayshadow[$cha]);
printf ("   - prev PSGf:  0x%02x%02x\n",$psgshadow['hi'][$cha],$psgshadow['lo'][$cha]);
		$fnum   = psgfnum($ayshadow[$cha]);
printf ("   -  new PSGf:  0x%04x\n",$fnum);
		$fnumLo = ($fnum & 0xff);
printf ("   -             LO = 0x%02x\n",$fnumLo);
		$fnumHi = ($fnum & 0x0f00) >> 8;
printf (" -               HI = 0x%02x\n",$fnumHi);
		if ($fnumLo != $psgshadow['lo'][$cha]) {
			$psgshadow['lo'][$cha] = $fnumLo;
printf ( " ===== about to call generate with cha = %d, 4*cha = %d\n", $cha, 4*$cha);
			generate(2,4*$cha,$fnumLo);
		}
		if ($fnumHi != $psgshadow['hi'][$cha]) {
			$psgshadow['hi'][$cha] = $fnumHi;
			generate(2,4*$cha+1,$fnumHi);
		}
		break;
	case 6: // noise period (5 bits)
		break;
	case 7: // tone/noise enable (tone = 3lsb, 0=ena. noise=bits 3-5)
		// do an edge detect with bit-fu
		// then send initializations to PSG voices if enable bit 1->0
		// or disable voices where enable bit 0->
printf("--------- SSG Mode Register ---------\n");
		$d &= 0x3f; // mask off the data port DDR bits.
		$changes = $ayshadow[4] ^ $d; // sense which bits have changed
printf("  - new value = 0x%02x - %s\n",$d,tobin($d));
printf("  - previous  = 0x%02x - %s\n",$ayshadow[4],tobin($ayshadow[4]));
printf("  - chnge msk = 0x%02x - %s\n",$changes,tobin($changes));
		$ayshadow[4] = $d;
		
		for ($cha = 0 ; $cha < 6 ; $cha++) {
printf("  - %d: ",$cha);
			if (($changes & 0x01) == 1) {
printf(" %10s ","changed");
				if ( ($d & 0x01) != 1 ) {
print " (activated)\n";
					// channel is enabled. Send inits
					if ($cha < 3) {
						$val = 0x3f; // square wave 50% duty cycle
					}
					else {
						$val = 0xc0; // noise
						// HACK to get drum working - do it right later
						generate(2,4*$cha,0x9a);
						generate(2,4*$cha+1,0x17); 
					}
					generate(2,4*$cha+3,$val);
					generate(2,4*$cha+2,$psgshadow['v'][$cha % 3]|0xc0);
				}
				else {
print " (disableded)\n";
					// channel is disabled. Mute it.
					generate(2,4*$cha+2,$psgshadow['v'][$cha % 3]);
printf(" ---- wrote %02x to register %02x\n",$psgshadow['v'][$cha % 3],4*$cha+2);
				}
			}
else { printf(" %10s\n","unchanged"); }
			$changes = $changes >> 1;
			$d = $d >> 1;
		}
		// TODO: see above. :)
		break;
	case 8:
	case 9:
	case 10: // volume for A,B,C
		$cha = $a-8;
		$d = $d & 0x0f;  // for now, mask off the M bit (b4) as well....
		//$d = $d << 2; // is this even accurate?  (answer from the future - not quite)
		$d = $PSGvolume[$d];
		$tonevolume = $d;
		$noisevolume = $d;
		// if the channel is enabled for square wave tones, enable the LR bits in PSG
		if ((($ayshadow[4] >> $cha) & 0x01) == 0) {
			$tonevolume |=  0xc0; // set L+R bits enabled
		}
		// if the channel is enabled for noise, enable the LR bits in the nose voice of PSG
		if ((($ayshadow[4] >> ($cha+3)) & 0x01) == 0) {
			$noisevolume |= 0xc0;
		}
		$psgshadow['v'][$cha] = $d;
		generate(2,4*$cha + 2,$tonevolume);
		generate(2,4*($cha + 3) + 2, $noisevolume);
		break;
	case 11: // env fine
	case 12: // env coarse
	case 13: // env shape/cycle
	default:
		// ignore register
	}
}

function translate_opn($a, $d, $base)
{
	global $opnfreqs;
	global $opnclock;

	$a0 = $a;
	$d0 = $d;
	
//if ($a >= 0x20) { return; }
	switch ($a>>4) {
	case 0: // regs 0x00-0x1F are for the SSG portion
	case 1:
		translate_ay($a,$d);
		return;
		break;
	case 2: // global FM parameters
		switch ($a) {
		case 0x21: 	// test register
		case 0x2d:  // set pre-scaler . (no explanation in dox)
		case 0x2e:	// set clock divider = 3 or 6 (how??)
		case 0x2f:	// set clock divider = 2
			return; // ignore
			break;
		case 0x24: // TimerA Hi
			$a = 0x10;
			break;
		case 0x25: // timerA Lo
			$a = 0x11;
			break;
		case 0x26: // TimerB
			$a = 0x12;
			break;
		case 0x27:
			// Mode register
			$mode = ($d & 0xc0) >> 6;
			$a = 0x14;
			// mask off bits 2-3 (IRQ Ena) and 6-7 (unused / CSM)
			$d = $d & 0x33;
			if ($mode > 1) { print "illegal mode setting\n"; }
			else if ($mode > 0) { print "special mode enabled\n"; }
			// TODO: anything needed for special mode?
			// for now, we'll ignore special mode.
			break;
		case 0x28:
			// keyOnOff register
			$ops = ($d & 0xf0) >> 1;
			$cha = $d & 0x07;
			if ($cha == 3) {
				printf("invalid Keyon channel %d\n", $cha);
				return;
			}
			$cha += $base;
			$a = 0x08;
			$d = $ops + $cha;
			break;
		default:
			printf("Invalid global FM register 0x%02x\n",$a);
			return;
		}
		break;
	case 3: // DT1 + MUL	
	case 4: // TL	(same)
	case 5: // RS + AR
	case 6: // AM + D1R
	case 7: // D2R
	case 8: // D1L + RR
		$cha = $a & 3;
		if ($cha == 3) {
			printf("invalid channel write 0x%02x\n",$a);
			return;
		}
		$cha += $base;
		$op = ($a >> 2) & 3;
//		if ($op == 1) { $op = 2; }
//		else if ($op == 2) { $op = 1; }
		$r = (($a >> 4) - 3) * 0x20;
		$r += 0x40;
		$r += 8 * $op + $cha;
		$a = $r;
		// $d is unchanged. Neato!
		break;
	case 9: // SSG-EG (ignore)
		return;
		break;
	case 0xA:
		// A0-A2 = Fnum LSB
		// A4-A6 = Block + Freq MSB
		// 
		$cha = $a & 3;
		if ($cha == 3) {
			printf("invalid channel write 0x%02x\n",$a);
			return;
		}
		$cha += $base;
		if ($a >= 0xa8) {
			printf("ignoring special mode voice 3 setting to 0x%02x\n",$a);
			return;
		}
		if ($a < 0xa4) {
			// setting LSB - set the freq
			if ($opnfreqs[$cha] != 0x80) {
				// do some jiggery-pokery to convert to OPM KC value:
				$oct = (($opnfreqs[$cha] >> 3)-0) & 0x07;
				$oct = $oct << 4;
				$f = ($d | ($opnfreqs[$cha] << 8)) & 0x07ff;
				// The following formula appears in a snippet from the unicorn that
				// is the YM2203 application manual (not the datasheet)
				// shown in a post to a thread at vgmrips.net:
				// https://vgmrips.net/forum/viewtopic.php?f=15&t=2907
				$pitch = ($opnclock * pow(2,($oct>>4)-1) * $f) / ( 144 * (1 << 20));
printf("note: ch=%d f=%d oct=%d : pitch=%2f\n",$cha,$f,($oct>>4),$pitch);
				$a = 0x28 + $cha;
				$d = getcode($pitch);
				$opnfreqs[$cha] = 0x80;
			}
			else {
				print "VGM sets the LSB w/o first setting the MSB. Skipping note\n";
				return;
			}
		}
		else {
			// setting MSB and Block (octave)
			$opnfreqs[$cha] = $d & 0x3f;
			return;
		}
		break;
	case 0xB:	// FB & Connect ALG
		if ($a > 0xb2) {
			printf ("invalid FB / CON register 0x%02\n",$a);
			return;
		}
		$a -= 0x90 + $base;
		$d |= 0xc0; // since 2203 doesn't have L/R set bits here...
		break;
	default:
		printf ("Unsupported register %02x\n",$a);
		return;
	}
	if ($a0 < 0x20) {
		printf ("2203(%d): 0x%02x 0x%02x -> 2151: 0x%02x 0x%02x\n",$base, $a0, $d0, $a, $d);
	}
	else {
		if ($a0 == 0x28) { $opncha = $d0 & 0x0f; } else { $opncha = $a0 % 4; }
		if ($a == 0x08) { $opmcha = $d & 0x07; } else { $opmcha = $a % 8; }
		printf ("2203(%d): 0x%02x 0x%02x (ch %d) -> 2151: 0x%02x 0x%02x (ch %d)\n",$base, $a0, $d0, $opncha, $a, $d, $opmcha);
		if ($a0 >= 0xa0 && $a0 < 0xaf) {
			printf ("       : Freq %d %4d ---> 2151 KC 0x%02x\n", $oct/16,$f,$d);
		}
	}
	generate(1,$a,$d); // send the translated reg/val as if it were for YM.
}

$filesize=filesize(FILENAME);
$f = fopen(FILENAME, "r");
$binary=fread($f,$filesize);
fclose($f);

$vgm=unpack(sprintf('C%d',$filesize),$binary);

$vgm = array_values($vgm);

if (($vgm[0x09] < 2) && ($vgm[0x08] < 0x50)) {
	$i = 0x40;
}
else {
	$i = OFFSET;
	$i += $vgm[OFFSET];
	$i += $vgm[OFFSET+1] << 8;
	$i += $vgm[OFFSET+2] << 16;
	$i += $vgm[OFFSET+3] << 24;
}

$opnclock = 0;
$opnclock += $vgm[0x44];
$opnclock += $vgm[0x45] << 8;
$opnclock += $vgm[0x46] << 16;
$opnclock += $vgm[0x47] << 24;
$opnclock &= 0xbfffffff; // bit 30 = dual chip flag. Ignore it.

$ayclock = 0;
$ayclock += $vgm[0x74];
$ayclock += $vgm[0x75] << 8;
$ayclock += $vgm[0x76] << 16;
$ayclock += $vgm[0x77] << 24;
$ayclock &= 0xbfffffff; // bit 30 = dual chip flag. Ignore it.


printf("OPN clock rate = %d\n",$opnclock);
//$opnclock *= 2; // Black Tiger
$opnclock *= 6; // for City Connection
if ($ayclock > 0 ) { $ayclock *= 1; }
else { $ayclock = $opnclock / 3; }


define ("EOF",count($vgm));

$ticks=0;
$totalticks=0;
$longest=0;
$maxatbyte=0;

$songdata=array();
$bytes=0;

$notecount=array();
$notecount[0x54]=0;
$notecount[0xbd]=0;
$notecount[0x55]=0;
$notecount[0xa5]=0;

$errors=array();

// A B C freqs, ENV period, Voice Enable byte
$ayshadow = array(0, 0, 0, 0, 0x3f); 

$psgshadow = array(
	'lo' => array(0,0,0,0,0,0), // lo freqs for 6 channels of PSG
	'hi' => array(0,0,0,0,0,0), // hi freqs for 6 channels of PSG
	'v'  => array(0,0,0)	// volumes for 3 channels (excluding L/R bits)
); 

while ($i < EOF) {
  $cmd = $vgm[$i];
  $i++;
  switch ($cmd) {
  case 0x54: // YM2151 chip
	$a = $vgm[$i];
	$d = $vgm[$i+1];
	$i += 2;
	//printf("[%6x] {%5d} YM A:%2x D:%2x\n",$i-3,$ticks,$a,$d);
	if ($a == 0x14) { $d = $d & 0xf3; } // filter out IRQ enable bits

	generate($cmd,$a,$d);
	$notecount[$cmd]++;
	break;
  case 0xa5: // second YM2203 chip
  case 0x55: // YM2203 chip
	$a = $vgm[$i];
	$d = $vgm[$i+1];
	$i += 2;
	if ($cmd == 0xa5) { translate_opn($a,$d,3); }
	else { translate_opn($a,$d,0); }
	$notecount[$cmd]++;
	break;
  case 0xa0: // AY8910 chip
    $a = $vgm[$i];
    $d = $vgm[$i+1];
    $i += 2;
    translate_ay($a,$d);
    break;
  case 0x61:
	$t = $vgm[$i] | ( $vgm[$i+1] << 8 );
	$i += 2;
	//printf("[%6x] {%5d} pause %d ticks\n",$i-3,$ticks,$t);
	$ticks += $t;
	break;
  case 0x62:
	//printf("[%6x] {%5d} pause 735 ticks (NTSC frame pause)\n",$i-1,$ticks);
	$ticks += 735;
	break;
  case 0x63:
	//printf("[%6x] {%5d} pause 882 ticks (PAL frame pause)\n",$i-1,$ticks);
	$ticks += 882;
	break;
  case 0x66:
	$i=EOF;
	break;
  case 0x67:
	$t = $i-1; // store the address of the command before skipping data
	$i+=2;
	$datasize=$vgm[$i] | $vgm[$i+1]<<8 | $vgm[$i+2]<<16 | $vgm[$i+3]<<24;
	$i += $datasize + 4;
	printf("[%6x] Data block (%4x)\n",$t,$datasize);
	break;
  case 0xB5:  // Ignore common PCM chip writes.
  case 0xB6:
  case 0xB7:
  case 0xB8:
  case 0xB9:
  case 0xBA:
  case 0xBB:
  case 0xBC:
  case 0xBD: // SAA1099 chip
  case 0xBE:
  case 0xBF:
	//printf("[%6x] {%5d} Ignore command %2x\n",$i-1,$ticks,$cmd);
  	$i += 2;
  	break;
  // skip commands with 3-byte operands
  case 0xc0: // Ignore Sega PCM commands.
  case 0xc1:
  case 0xc2:
  case 0xc3:
  case 0xc4:
  case 0xc5:
  case 0xc6:
  case 0xc7:
  case 0xc8:
  case 0xd0:
  case 0xd1:
  case 0xd2:
  case 0xd3:
  case 0xd4:
  case 0xd5:
  case 0xd6:
	//printf("[%6x] {%5d} Ignore command %2x\n",$i-1,$ticks,$cmd);
	$i += 3;
	break;
  case 0x70:
  case 0x71:
  case 0x72:
  case 0x73:
  case 0x74:
  case 0x75:
  case 0x76:
  case 0x77:
  case 0x78:
  case 0x79:
  case 0x7a:
  case 0x7b:
  case 0x7c:
  case 0x7d:
  case 0x7e:
  case 0x7f:
	$t = ( $cmd & 0x0f ) + 1;
	//printf("[%6x] {%5d} pause %d ticks (cmd 7x)\n",$i-1,$ticks,$t);
  	$ticks += $t;
	break;
  case 0x66:
	// End of sound data
	$i = EOF;
	break;
  default:
	array_push($errors, sprintf ("[%6x] : Unknown command (%2x)\n",$i-1,$cmd));
	break;
  }; // end of switch()
};

array_push($songdata,$commands[0x66]);

print "; ".$notecount[0x54]." YM2151 messages\n";
print "; ".$notecount[0xbd]." SAA1099 messages\n";
print "; $totalticks total ticks\n\n";

foreach ( $errors as $message ) { print "; $message"; };

if(1==2) {
print "DONE - total time ticks = $totalticks\n";
print "     - longest pause    = $longest\n";
printf("                        @ 0x%4x\n",$maxatbyte);
};

out_zsm(OUTFILENAME);
//out_asm();
print "; $bytes bytes of data\n";

?>
